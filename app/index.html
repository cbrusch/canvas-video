<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>Three.js: Video Object Example</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
	<link rel="stylesheet" href="css/app.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
	<script src="js/three.min.js"></script>
	<script src="js/renderers/Projector.js"></script>
	<script src="js/renderers/CanvasRenderer.js"></script>
	<script src="js/libs/stats.min.js"></script>
</head>
<body>
<!-- https://threejs.org/examples/#canvas_materials_video -->
	<video id="video" autoplay loop webkit-playsinline> 
		<source src="threejs/textures/sintel.mp4" type='video/mp4; codecs="avc1.4201E, mp4a.40.2"'>
		<source src="threejs/textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
	</video>

	<script>
		var AMOUNT = 100;

		var container, stats;

		var camera, scene, renderer, mesh;

		var video, image, imageContext, imageReflection, imageReflectionContext, imageReflectionGradient, texture, textureReflection;

		var mouseX = 0;
		var mouseY = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		init();
		animate();

		function init() {
			container = document.createElement('div');
			document.body.appendChild(container);
// I don't need an info box
			// container = document.createElement( 'div' );
			// document.body.appendChild( container );
			// var info = document.createElement( 'div' );
			// info.style.position = 'absolute';
			// info.style.top = '10px';
			// info.style.width = '100%';
			// info.style.textAlign = 'center';
			// info.innerHTML = '<a href="http://threejs.org" target="_blank">three.js</a> - video demo. playing <a href="http://durian.blender.org/" target="_blank">sintel</a> trailer';
			// container.appendChild( info );

			camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.z = 1000;
			scene = new THREE.Scene();
			video = document.getElementById('video');
			image = document.createElement('canvas');
			image.width = 480;
			image.height = 204;
			imageContext = image.getContext('2d');
			imageContext.fillStyle = '#000000';
			imageContext.fillRect(0, 0, 480, 204);

			texture = new THREE.Texture(image);
			var material = new THREE.MeshBasicMaterial({ map: texture, overdraw: 0.5 });

// I don't understand why I need the reflection part if I'm not using it. The video doesn't work without having this
			imageReflection = document.createElement('canvas');
			imageReflection.width = 480;
			imageReflection.height = 204;
			imageReflectionContext = imageReflection.getContext('2d');
			imageReflectionContext.fillStyle = '#000000';
			imageReflectionContext.fillRect(0, 0, 480, 204);
			imageReflectionGradient = imageReflectionContext.createLinearGradient(0, 0, 0, 204);
			imageReflectionGradient.addColorStop( 0.2, 'rgba(240, 240, 240, 1)' );
			imageReflectionGradient.addColorStop( 1, 'rgba(240, 240, 240, 0.8)' );
			textureReflection = new THREE.Texture(imageReflection);
			var materialReflection = new THREE.MeshBasicMaterial({ map: textureReflection, side: THREE.BackSide, overdraw: 0.5 });

			var plane = new THREE.PlaneGeometry(480, 204, 4, 4);
			mesh = new THREE.Mesh( plane, material );
			mesh.scale.x = mesh.scale.y = mesh.scale.z = 1.5;
			scene.add(mesh);

// Add this back in to display the reflection plane
			// mesh = new THREE.Mesh( plane, materialReflection );
			// mesh.position.y = -306;
			// mesh.rotation.x = - Math.PI;
			// mesh.scale.x = mesh.scale.y = mesh.scale.z = 1.5;
			// scene.add(mesh);

			var separation = 150;
			var amountX = 10;
			var amountY = 10;
			var PI2 = Math.PI * 2;
			var material = new THREE.SpriteCanvasMaterial({
				color: 0x0808080,
				program: function(context) {
					context.beginPath();
					context.arc( 0, 0, 0.5, 0, PI2, true );
					context.fill();
				}
			});
			for( var ix = 0; ix < amountX; ix++ ) {
				for( var iy = 0; iy < amountY; iy++ ) {
					particle = new THREE.Sprite(material);
					particle.position.x = ix * separation - ( (amountX * separation)/2 );
					particle.position.y = -153;
					particle.position.z = iy * separation - ( (amountY * separation)/2 );
					particle.scale.x = particle.scale.y = 2;
					scene.add(particle);
				}
			}

			renderer = new THREE.CanvasRenderer();
			renderer.setClearColor(0xf0f0f0);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);
			stats = new Stats();
			container.appendChild(stats.dom);
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			window.addEventListener( 'resize', onWindowResize, false );
		}

		function onDocumentMouseMove(event) { // tracks mouse movement
			mouseX = ( event.clientX - windowHalfX );
			mouseY = ( event.clientY - windowHalfY ) * 0.2;
		}

		function onWindowResize() { // adjusts camera position and video size based on browser window size
			windowHalfX = window.innerWidth / 2; // These are already defined globally, not sure why I need to repeat them here
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function animate() {
			requestAnimationFrame(animate);
			render();
			stats.update();
		}

		function render() {
			camera.position.x += ( mouseX - camera.position.x ) * 0.05; // maps camera to mouse position
			camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
			camera.lookAt(scene.position);

			if( video.readyState === video.HAVE_ENOUGH_DATA ) { // draws video frames
				imageContext.drawImage(video, 0, 0);

				if(texture) texture.needsUpdate = true; // I don't understand the syntax of this texture if statement
// Add this back in to animate the reflection plane
				// if(textureReflection) textureReflection.needsUpdate = true;
			}

// Add this back in to render the reflection plane
			// imageReflectionContext.drawImage( image, 0, 0 );
			// imageReflectionContext.fillStyle = imageReflectionGradient;
			// imageReflectionContext.fillRect (0, 0, 480, 204 );

			renderer.render( scene, camera ); // render to make scene visible in the browser
		}
	</script>
</body>
</html>









