<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<title>Three.js: Video Object Example</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
	<link rel="stylesheet" href="css/app.css">
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
	<script src="js/three.min.js"></script>
	<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
	<script src="js/utils/Detector.js"></script>
	<script src="js/renderers/Projector.js"></script>
	<script src="js/renderers/CanvasRenderer.js"></script>
	<script src="js/libs/stats.min.js"></script>
</head>
<body>
<!-- https://threejs.org/examples/#canvas_materials_video -->
	<video id="video" autoplay loop webkit-playsinline> 
		<source src="threejs/textures/sintel.mp4" type='video/mp4; codecs="avc1.4201E, mp4a.40.2"'>
		<source src="threejs/textures/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'>
	</video>

	<script>
		// var THREE = require('three');
		// var OrbitControls = require('three-orbit-controls');
		var AMOUNT = 100;

// MAIN
		var container, stats, controls;
		var camera, scene, renderer, mesh;
		var video, image, imageContext, imageReflection, imageReflectionContext, imageReflectionGradient, texture, textureReflection;
		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

// CUSTOM
		var focalLength = 45;
		var aspect = window.innerWidth / window.innerHeight;
		var viewNear = 400;
		var viewFar = 10000;
		var projector;
		var mouse = {x: 0, y: 0};
		var INTERSECTED;
		
		if(Detector.webgl) { // Detect whether webgl is supported by the client's browser
			init();
			animate();
		}
		else {
			var warning = Detector.getWebGLErrorMessage();
			container = document.createElement('div');
			document.body.appendChild(container);
			container.appendChild(warning);
		}

// FUNCTIONS
		function init() {
			container = document.createElement('div');
			document.body.appendChild(container);

// CAMERA & SCENE SETUP
			/* https://threejs.org/docs/#Reference/Cameras/PerspectiveCamera */
			camera = new THREE.PerspectiveCamera( focalLength, aspect, viewNear, viewFar );
			camera.position.set(0, 1, 1000);
			scene = new THREE.Scene();
			video = document.getElementById('video');
			image = document.createElement('canvas');
			image.width = 480;
			image.height = 204;
			imageContext = image.getContext('2d');
			imageContext.fillStyle = '#000000';
			imageContext.fillRect(0, 0, image.width, image.height);

// WORLD
			projector = new THREE.Projector();
			texture = new THREE.Texture(image);
			var material = new THREE.MeshBasicMaterial({ map: texture, overdraw: 0.5 });

// I don't understand why I need the reflection part if I'm not using it. The video doesn't work without having this
			imageReflection = document.createElement('canvas');
			imageReflection.width = image.width;
			imageReflection.height = image.height;
			imageReflectionContext = imageReflection.getContext('2d');
			imageReflectionContext.fillStyle = '#000000';
			imageReflectionContext.fillRect(0, 0, image.width, image.height);
			imageReflectionGradient = imageReflectionContext.createLinearGradient(0, 0, 0, image.height);
			imageReflectionGradient.addColorStop( 0.2, 'rgba(240, 240, 240, 1)' );
			imageReflectionGradient.addColorStop( 1, 'rgba(240, 240, 240, 0.8)' );
			textureReflection = new THREE.Texture(imageReflection);
			var materialReflection = new THREE.MeshBasicMaterial({ map: textureReflection, side: THREE.BackSide, overdraw: 0.5 });

// FLOOR
			var plane = new THREE.PlaneGeometry(image.width, image.height, 4, 4);
			mesh = new THREE.Mesh( plane, material );
			mesh.scale.x = mesh.scale.y = mesh.scale.z = 1.5; //this seems to set the depth of the canvas in relation to the perpendicular particle plane
			scene.add(mesh);

			var separation = 150;
			var amountX = 10;
			var amountY = 10;
			var PI2 = Math.PI * 2;
			var material = new THREE.SpriteCanvasMaterial({
				color: 0x0808080,
				program: function(context) {
					context.beginPath();
					context.arc( 0, 0, 0.5, 0, PI2, true );
					context.fill();
				}
			});
			for( var ix = 0; ix < amountX; ix++ ) {
				for( var iy = 0; iy < amountY; iy++ ) {
					particle = new THREE.Sprite(material);
					particle.position.x = ix * separation - ( (amountX * separation)/2 );
					particle.position.y = -153;
					particle.position.z = iy * separation - ( (amountY * separation)/2 );
					particle.scale.x = particle.scale.y = 2;
					scene.add(particle);
				}
			}

// RENDERER
			renderer = new THREE.CanvasRenderer();
			renderer.setClearColor(0xf0f0f0);
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			container.appendChild(renderer.domElement);

// CONTROLS
			controls = new THREE.OrbitControls(camera, renderer.domElement);

// STATS
			stats = new Stats();
			container.appendChild(stats.dom);

// EVENTS
			document.addEventListener( 'mousemove', onDocumentMouseMove, false );
			window.addEventListener( 'resize', onWindowResize, false );
		}

		function onDocumentMouseMove(event) {
			// This now seems to allow me to drag to tilt the video canvas, but I want it to be static
			mouse.x = ( event.clientX - windowHalfX ) * 0.02 - 1;
			mouse.y = ( event.clientY - windowHalfY ) * 0.02 + 1;
			console.log(mouse.x + ", " + mouse.y);
		}

		function onWindowResize() {
			windowHalfX = window.innerWidth / 2; // These are already defined globally, not sure why I need to repeat them here
			windowHalfY = window.innerHeight / 2;

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function animate() {
			requestAnimationFrame(animate);
			render();
			update();
		}

		function render() {
			//This doesn't seem to be necessary now that I've removed the side-to-side camera movements
			// camera.lookAt(scene.position);

			if( video.readyState === video.HAVE_ENOUGH_DATA ) { // draws video frames
				imageContext.drawImage(video, 0, 0);

				if(texture) texture.needsUpdate = true; // I don't understand the syntax of this texture if statement
			}

			renderer.render( scene, camera ); // render to make scene visible in the browser
		}

// SCROLLING
/* https://stemkoski.github.io/Three.js/Mouse-Over.html */
		function update() {
			// find intersections

			// create a Ray with origin at the mouse position
			//   and direction into the scene (camera direction)
			var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
			projector.unprojectVector( vector, camera );
			var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

			// create an array containing all objects in the scene with which the ray intersects
			var intersects = ray.intersectObjects( scene.children );

			// INTERSECTED = the object in the scene currently closest to the camera 
			//		and intersected by the Ray projected from the mouse position 	
			
			// if there is one (or more) intersections
			if ( intersects.length > 0 )
			{
				// if the closest object intersected is not the currently stored intersection object
				if ( intersects[ 0 ].object != INTERSECTED ) 
				{
				    // restore previous intersection object (if it exists) to its original color
					if ( INTERSECTED ) 
						INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
					// store reference to closest object as current intersection object
					INTERSECTED = intersects[ 0 ].object;
					// store color of closest object (for later restoration)
					INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
					// set a new color for closest object
					INTERSECTED.material.color.setHex( 0xffff00 );
				}
			} 
			else // there are no intersections
			{
				// restore previous intersection object (if it exists) to its original color
				if ( INTERSECTED ) 
					INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
				// remove previous intersection object reference
				//     by setting current intersection object to "nothing"
				INTERSECTED = null;
			}


			// if ( keyboard.pressed("z") ) 
			// { 
			// 	// do something
			// }
			
			controls.update();
			stats.update();
		}
	</script>
</body>
</html>









